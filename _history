{"entries":[{"timestamp":1768911506482,"editorVersion":"2.0.63","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":180,"length1":43,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":209,"length1":79,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// テストはここに来ます。このパッケージが拡張機能として使用されるときにはコンパイルされません。\n"},{"type":"added","filename":"custom.ts","value":"namespace browserEvents {\n    export enum Event {\n        //% block=\"pointer down\"\n        PointerDown = 6857,\n        //% block=\"pointer up\"\n        PointerUp = 6858,\n        //% block=\"pointer move\"\n        PointerMove = 6859,\n        //% block=\"pointer leave\"\n        PointerLeave = 6860,\n        //% block=\"pointer enter\"\n        PointerEnter = 6861,\n        //% block=\"pointer cancel\"\n        PointerCancel = 6862,\n        //% block=\"pointer over\"\n        PointerOver = 6863,\n        //% block=\"pointer out\"\n        PointerOut = 6864,\n        //% block=\"wheel\"\n        Wheel = 6865,\n        //% block=\"key down\"\n        KeyDown = 6866,\n        //% block=\"key up\"\n        KeyUp = 6867\n    }\n\n    export class _SceneButtonHandlers<U> {\n        protected handlers: ButtonHandler<U>[];\n\n        constructor(public id: number, protected invokeHandler: (handler: U) => void) {\n            this.handlers = [];\n        }\n\n        onEvent(event: number, handler: U) {\n            this.getHandler(event, true).handler = handler;\n        }\n\n        addEventListener(event: number, handler: U) {\n            this.getHandler(event, true).listeners.push(handler);\n        }\n\n        removeEventListener(event: number, handler: U) {\n            const eventHandler = this.getHandler(event);\n\n            if (eventHandler) {\n                eventHandler.listeners = eventHandler.listeners.filter(h => h !== handler);\n            }\n        }\n\n        protected getHandler(event: number, createIfMissing?: boolean) {\n            for (const handler of this.handlers) {\n                if (handler.event === event) return handler;\n            }\n\n            if (createIfMissing) {\n                const newHandler = new ButtonHandler<U>(event, this.id, this.invokeHandler);\n                this.handlers.push(newHandler);\n                return newHandler;\n            }\n\n            return undefined;\n        }\n    }\n\n    class ButtonHandler<U> {\n        handler: U;\n        listeners: U[] = [];\n\n        constructor(public readonly event: number, id: number, invokeHandler: (handler: U) => void) {\n            control.onEvent(event, id, () => {\n                if (this.handler) {\n                    invokeHandler(this.handler);\n                }\n                for (const listener of this.listeners) {\n                    invokeHandler(listener);\n                }\n            });\n        }\n    }\n\n    export enum Key {\n        Zero = 48,\n        One = 49,\n        Two = 50,\n        Three = 51,\n        Four = 52,\n        Five = 53,\n        Six = 54,\n        Seven = 55,\n        Eight = 56,\n        Nine = 57,\n        BackTick = 192,\n        Hyphen = 189,\n        Equals = 187,\n        Q = 81,\n        W = 87,\n        E = 69,\n        R = 82,\n        T = 84,\n        Y = 89,\n        U = 85,\n        I = 73,\n        O = 79,\n        P = 80,\n        OpenBracket = 219,\n        CloseBracket = 221,\n        BackSlash = 220,\n        A = 65,\n        S = 83,\n        D = 68,\n        F = 70,\n        G = 71,\n        H = 72,\n        Space = 32,\n        PageUp = 33,\n        J = 74,\n        K = 75,\n        L = 76,\n        SemiColon = 186,\n        Apostrophe = 222,\n        Z = 90,\n        X = 88,\n        C = 67,\n        V = 86,\n        B = 66,\n        N = 78,\n        M = 77,\n        Comma = 188,\n        Period = 190,\n        ForwardSlash = 191,\n        Shift = 16,\n        Enter = 13,\n        CapsLock = 20,\n        Tab = 9,\n        Control = 17,\n        Meta = 91,\n        Alt = 18,\n        ArrowUp = 38,\n        ArrowDown = 40,\n        ArrowLeft = 37,\n        ArrowRight = 39,\n        PageDown = 34,\n        End = 35,\n        Home = 36,\n        LeftShift = 1016,\n        RightShift = 1017,\n        LeftControl = 1018,\n        RightControl = 1019,\n        Backspace = 8,\n        Delete = 46,\n    }\n\n    export enum KeyEvent {\n        //% block=\"pressed\"\n        Pressed = 6872,\n        //% block=\"released\"\n        Released = 6873,\n        //% block=\"repeat\"\n        Repeat = 6874\n    }\n\n    //% whenUsed\n    const INTERNAL_KEY_DOWN = 6870;\n    //% whenUsed\n    const INTERNAL_KEY_UP = 6871;\n\n    export function keyToString(key: Key) {\n        switch (key) {\n            case Key.Q:\n                return \"Q\";\n            case Key.W:\n                return \"W\";\n            case Key.E:\n                return \"E\";\n            case Key.R:\n                return \"R\";\n            case Key.T:\n                return \"T\";\n            case Key.Y:\n                return \"Y\";\n            case Key.U:\n                return \"U\";\n            case Key.I:\n                return \"I\";\n            case Key.O:\n                return \"O\";\n            case Key.P:\n                return \"P\";\n            case Key.OpenBracket:\n                return \"[\";\n            case Key.CloseBracket:\n                return \"]\";\n            case Key.BackSlash:\n                return \"\\\\\";\n            case Key.A:\n                return \"A\";\n            case Key.S:\n                return \"S\";\n            case Key.D:\n                return \"D\";\n            case Key.F:\n                return \"F\";\n            case Key.G:\n                return \"G\";\n            case Key.H:\n                return \"H\";\n            case Key.Space:\n                return \" \";\n            case Key.PageUp:\n                return \"PageUp\";\n            case Key.J:\n                return \"J\";\n            case Key.K:\n                return \"K\";\n            case Key.L:\n                return \"L\";\n            case Key.SemiColon:\n                return \";\";\n            case Key.Apostrophe:\n                return \"'\";\n            case Key.Z:\n                return \"Z\";\n            case Key.X:\n                return \"X\";\n            case Key.C:\n                return \"C\";\n            case Key.V:\n                return \"V\";\n            case Key.B:\n                return \"B\";\n            case Key.N:\n                return \"N\";\n            case Key.M:\n                return \"M\";\n            case Key.Comma:\n                return \",\";\n            case Key.Period:\n                return \".\";\n            case Key.ForwardSlash:\n                return \"/\";\n            case Key.Shift:\n                return \"Shift\";\n            case Key.Enter:\n                return \"Enter\";\n            case Key.CapsLock:\n                return \"CapsLock\";\n            case Key.Tab:\n                return \"Tab\";\n            case Key.Control:\n                return \"Control\";\n            case Key.Meta:\n                return \"Meta\";\n            case Key.Alt:\n                return \"Alt\";\n            case Key.ArrowUp:\n                return \"ArrowUp\";\n            case Key.ArrowDown:\n                return \"ArrowDown\";\n            case Key.ArrowLeft:\n                return \"ArrowLeft\";\n            case Key.ArrowRight:\n                return \"ArrowRight\";\n            case Key.PageDown:\n                return \"PageDown\";\n            case Key.End:\n                return \"End\";\n            case Key.Home:\n                return \"Home\";\n            case Key.Zero:\n                return \"0\";\n            case Key.One:\n                return \"1\";\n            case Key.Two:\n                return \"2\";\n            case Key.Three:\n                return \"3\";\n            case Key.Four:\n                return \"4\";\n            case Key.Five:\n                return \"5\";\n            case Key.Six:\n                return \"6\";\n            case Key.Seven:\n                return \"7\";\n            case Key.Eight:\n                return \"8\";\n            case Key.Nine:\n                return \"9\";\n            case Key.BackTick:\n                return \"`\";\n            case Key.Hyphen:\n                return \"-\";\n            case Key.Equals:\n                return \"=\";\n            case Key.LeftShift:\n                return \"LeftShift\";\n            case Key.RightShift:\n                return \"RightShift\";\n            case Key.LeftControl:\n                return \"LeftControl\";\n            case Key.RightControl:\n                return \"RightControl\";\n            case Key.Backspace:\n                return \"Backspace\";\n            case Key.Delete:\n                return \"Delete\";\n        }\n    }\n\n    //% whenUsed\n    let _buttonsPendingInit: KeyButton[];\n\n    let defaultRepeatDelay = 500;\n    let defaultRepeatInterval = 30;\n    let _lastKeyPressed: Key = 0;\n\n    type KeyHandler = () => void;\n    type KeyCodeHandler = (key: Key) => void;\n\n    //% fixedInstances\n    export class KeyButton {\n        protected _pressed: boolean;\n        public repeatDelay: number;\n        public repeatInterval: number;\n        private _repeatCount: number;\n        private _pressedElapsed: number;\n\n        protected sceneStack: _SceneButtonHandlers<KeyHandler>[];\n        protected sceneStackWithKey: _SceneButtonHandlers<KeyCodeHandler>[];\n\n        protected get state(): _SceneButtonHandlers<KeyHandler> {\n            return this.sceneStack[this.sceneStack.length - 1];\n        }\n\n        protected get stateWithKey(): _SceneButtonHandlers<KeyCodeHandler> {\n            return this.sceneStackWithKey[this.sceneStackWithKey.length - 1];\n        }\n\n        constructor(public id: number) {\n            // use internalOnEvent so that events fire regardless of the current scene\n            control.internalOnEvent(INTERNAL_KEY_UP, this.id, () => this.setPressed(false), 16);\n            control.internalOnEvent(INTERNAL_KEY_DOWN, this.id, () => this.setPressed(true), 16);\n            this._pressed = false;\n\n            // this code may run before game/scene.ts, in which case calling this.__registerUpdate\n            // will trigger an exception. to prevent that, start a thread that pauses until we\n            // detect that an event context has been registered and then call it\n            if (control.eventContext()) {\n                this.__registerUpdate();\n            }\n            else {\n                if (!_buttonsPendingInit) {\n                    _buttonsPendingInit = [];\n                    control.runInBackground(() => {\n                        pauseUntil(() => !!control.eventContext());\n                        for (const button of _buttonsPendingInit) {\n                            button.__registerUpdate();\n                        }\n                        _buttonsPendingInit = undefined;\n                    });\n                }\n                _buttonsPendingInit.push(this);\n            }\n\n            this.sceneStack = [new _SceneButtonHandlers<KeyHandler>(id, invokeKeyHandler)];\n            this.sceneStackWithKey = [new _SceneButtonHandlers<KeyCodeHandler>(id, (handler: KeyCodeHandler) => invokeKeyHandlerWithCode(handler, this.id))];\n\n            game.addScenePushHandler(() => {\n                this.sceneStack.push(new _SceneButtonHandlers<KeyHandler>(id, invokeKeyHandler));\n                this.sceneStackWithKey.push(new _SceneButtonHandlers<KeyCodeHandler>(id, (handler: KeyCodeHandler) => invokeKeyHandlerWithCode(handler, this.id)));\n                this.__registerUpdate();\n            });\n            game.addScenePopHandler(() => {\n                this.sceneStack.pop();\n                this.sceneStackWithKey.pop();\n                if (this.sceneStack.length === 0) {\n                    this.sceneStack = [new _SceneButtonHandlers<KeyHandler>(id, invokeKeyHandler)];\n                    this.sceneStackWithKey = [new _SceneButtonHandlers<KeyCodeHandler>(id, (handler: KeyCodeHandler) => invokeKeyHandlerWithCode(handler, this.id))];\n                    this.__registerUpdate();\n                }\n            });\n        }\n\n        setPressed(pressed: boolean) {\n            if (this._pressed === pressed) return;\n\n            this._pressed = pressed;\n            if (pressed) {\n                _lastKeyPressed = this.id as Key;\n                this._repeatCount = 0;\n                this._pressedElapsed = 0;\n                control.raiseEvent(KeyEvent.Pressed, this.id);\n            }\n            else {\n                control.raiseEvent(KeyEvent.Released, this.id);\n            }\n        }\n\n        //% blockId=browserEvents_key_onEvent\n        //% block=\"on $this key $event\"\n        //% group=\"Keyboard\"\n        //% weight=100\n        onEvent(event: KeyEvent, handler: () => void) {\n            this.state.onEvent(event, handler);\n        }\n\n        onEventWithKey(event: KeyEvent, handler: (key: Key) => void) {\n            this.stateWithKey.onEvent(event, handler);\n        }\n\n        //% blockId=browserEvents_key_isPressed\n        //% block=\"is $this key pressed\"\n        //% group=\"Keyboard\"\n        //% weight=90\n        isPressed() {\n            return this._pressed;\n        }\n\n        //% blockId=browserEvents_key_pauseUntil\n        //% block=\"pause until $this key is $event\"\n        //% group=\"Keyboard\"\n        //% weight=80\n        pauseUntil(event: KeyEvent) {\n            control.waitForEvent(event, this.id)\n        }\n\n        addEventListener(event: KeyEvent, handler: () => void) {\n            this.state.addEventListener(event, handler);\n        }\n\n        addEventListenerWithKey(event: KeyEvent, handler: (key: Key) => void) {\n            this.stateWithKey.addEventListener(event, handler);\n        }\n\n        removeEventListener(event: KeyEvent, handler: () => void) {\n            this.state.removeEventListener(event, handler);\n        }\n\n        removeEventListenerWithKey(event: KeyEvent, handler: (key: Key) => void) {\n            this.stateWithKey.removeEventListener(event, handler);\n        }\n\n        __update() {\n            const delay = this.repeatDelay === undefined ? defaultRepeatDelay : this.repeatDelay;\n            const interval = this.repeatInterval === undefined ? defaultRepeatInterval : this.repeatInterval;\n            if (!this._pressed) return;\n            this._pressedElapsed += game.eventContext().deltaTimeMillis;\n\n            // inital delay\n            if (this._pressedElapsed < delay)\n                return;\n\n            // repeat count for this step\n            const count = Math.floor((this._pressedElapsed - delay - interval) / interval);\n            if (count != this._repeatCount) {\n                this._repeatCount = count;\n                control.raiseEvent(KeyEvent.Repeat, this.id);\n            }\n        }\n\n        __registerUpdate() {\n            game.eventContext().registerFrameHandler(scene.CONTROLLER_PRIORITY, () => this.__update());\n        }\n    }\n\n    function invokeKeyHandler(handler: KeyHandler) {\n        handler();\n    }\n\n    function invokeKeyHandlerWithCode(handler: KeyCodeHandler, keyCode: number) {\n        handler(keyCode as Key);\n    }\n\n    //% fixedInstance whenUsed\n    export const A = new KeyButton(Key.A);\n\n    //% fixedInstance whenUsed\n    export const B = new KeyButton(Key.B);\n\n    //% fixedInstance whenUsed\n    export const C = new KeyButton(Key.C);\n\n    //% fixedInstance whenUsed\n    export const D = new KeyButton(Key.D);\n\n    //% fixedInstance whenUsed\n    export const E = new KeyButton(Key.E);\n\n    //% fixedInstance whenUsed\n    export const F = new KeyButton(Key.F);\n\n    //% fixedInstance whenUsed\n    export const G = new KeyButton(Key.G);\n\n    //% fixedInstance whenUsed\n    export const H = new KeyButton(Key.H);\n\n    //% fixedInstance whenUsed\n    export const I = new KeyButton(Key.I);\n\n    //% fixedInstance whenUsed\n    export const J = new KeyButton(Key.J);\n\n    //% fixedInstance whenUsed\n    export const K = new KeyButton(Key.K);\n\n    //% fixedInstance whenUsed\n    export const L = new KeyButton(Key.L);\n\n    //% fixedInstance whenUsed\n    export const M = new KeyButton(Key.M);\n\n    //% fixedInstance whenUsed\n    export const N = new KeyButton(Key.N);\n\n    //% fixedInstance whenUsed\n    export const O = new KeyButton(Key.O);\n\n    //% fixedInstance whenUsed\n    export const P = new KeyButton(Key.P);\n\n    //% fixedInstance whenUsed\n    export const Q = new KeyButton(Key.Q);\n\n    //% fixedInstance whenUsed\n    export const R = new KeyButton(Key.R);\n\n    //% fixedInstance whenUsed\n    export const S = new KeyButton(Key.S);\n\n    //% fixedInstance whenUsed\n    export const T = new KeyButton(Key.T);\n\n    //% fixedInstance whenUsed\n    export const U = new KeyButton(Key.U);\n\n    //% fixedInstance whenUsed\n    export const V = new KeyButton(Key.V);\n\n    //% fixedInstance whenUsed\n    export const W = new KeyButton(Key.W);\n\n    //% fixedInstance whenUsed\n    export const X = new KeyButton(Key.X);\n\n    //% fixedInstance whenUsed\n    export const Y = new KeyButton(Key.Y);\n\n    //% fixedInstance whenUsed\n    export const Z = new KeyButton(Key.Z);\n\n    //% fixedInstance whenUsed\n    export const Zero = new KeyButton(Key.Zero);\n\n    //% fixedInstance whenUsed\n    export const One = new KeyButton(Key.One);\n\n    //% fixedInstance whenUsed\n    export const Two = new KeyButton(Key.Two);\n\n    //% fixedInstance whenUsed\n    export const Three = new KeyButton(Key.Three);\n\n    //% fixedInstance whenUsed\n    export const Four = new KeyButton(Key.Four);\n\n    //% fixedInstance whenUsed\n    export const Five = new KeyButton(Key.Five);\n\n    //% fixedInstance whenUsed\n    export const Six = new KeyButton(Key.Six);\n\n    //% fixedInstance whenUsed\n    export const Seven = new KeyButton(Key.Seven);\n\n    //% fixedInstance whenUsed\n    export const Eight = new KeyButton(Key.Eight);\n\n    //% fixedInstance whenUsed\n    export const Nine = new KeyButton(Key.Nine);\n\n    //% fixedInstance whenUsed\n    export const Shift = new KeyButton(Key.Shift);\n\n    //% fixedInstance whenUsed\n    export const Enter = new KeyButton(Key.Enter);\n\n    //% fixedInstance whenUsed\n    export const CapsLock = new KeyButton(Key.CapsLock);\n\n    //% fixedInstance whenUsed\n    export const Tab = new KeyButton(Key.Tab);\n\n    //% fixedInstance whenUsed\n    export const Control = new KeyButton(Key.Control);\n\n    //% fixedInstance whenUsed\n    export const Meta = new KeyButton(Key.Meta);\n\n    //% fixedInstance whenUsed\n    export const Alt = new KeyButton(Key.Alt);\n\n    //% fixedInstance whenUsed\n    export const ArrowUp = new KeyButton(Key.ArrowUp);\n\n    //% fixedInstance whenUsed\n    export const ArrowDown = new KeyButton(Key.ArrowDown);\n\n    //% fixedInstance whenUsed\n    export const ArrowLeft = new KeyButton(Key.ArrowLeft);\n\n    //% fixedInstance whenUsed\n    export const ArrowRight = new KeyButton(Key.ArrowRight);\n\n    //% fixedInstance whenUsed\n    export const BackTick = new KeyButton(Key.BackTick);\n\n    //% fixedInstance whenUsed\n    export const Hyphen = new KeyButton(Key.Hyphen);\n\n    //% fixedInstance whenUsed\n    export const Equals = new KeyButton(Key.Equals);\n\n    //% fixedInstance whenUsed\n    export const OpenBracket = new KeyButton(Key.OpenBracket);\n\n    //% fixedInstance whenUsed\n    export const CloseBracket = new KeyButton(Key.CloseBracket);\n\n    //% fixedInstance whenUsed\n    export const BackSlash = new KeyButton(Key.BackSlash);\n\n    //% fixedInstance whenUsed\n    export const Space = new KeyButton(Key.Space);\n\n    //% fixedInstance whenUsed\n    export const PageUp = new KeyButton(Key.PageUp);\n\n    //% fixedInstance whenUsed\n    export const SemiColon = new KeyButton(Key.SemiColon);\n\n    //% fixedInstance whenUsed\n    export const Apostrophe = new KeyButton(Key.Apostrophe);\n\n    //% fixedInstance whenUsed\n    export const Comma = new KeyButton(Key.Comma);\n\n    //% fixedInstance whenUsed\n    export const Period = new KeyButton(Key.Period);\n\n    //% fixedInstance whenUsed\n    export const ForwardSlash = new KeyButton(Key.ForwardSlash);\n\n    //% fixedInstance whenUsed\n    export const PageDown = new KeyButton(Key.PageDown);\n\n    //% fixedInstance whenUsed\n    export const End = new KeyButton(Key.End);\n\n    //% fixedInstance whenUsed\n    export const Home = new KeyButton(Key.Home);\n\n    //% fixedInstance whenUsed\n    export const LeftShift = new KeyButton(Key.LeftShift);\n\n    //% fixedInstance whenUsed\n    export const RightShift = new KeyButton(Key.RightShift);\n\n    //% fixedInstance whenUsed\n    export const LeftControl = new KeyButton(Key.LeftControl);\n\n    //% fixedInstance whenUsed\n    export const RightControl = new KeyButton(Key.RightControl);\n\n    //% fixedInstance whenUsed\n    export const Backspace = new KeyButton(Key.Backspace);\n\n    //% fixedInstance whenUsed\n    export const Delete = new KeyButton(Key.Delete);\n\n    //% fixedInstance whenUsed\n    export const Any = new KeyButton(0);\n\n    //% blockId=browser_events_setKeyboardRepeatDefault\n    //% block=\"set keyboard repeat delay $delay ms interval $interval ms\"\n    //% delay.defl=500\n    //% interval.defl=30\n    //% group=\"Keyboard\"\n    //% weight=0\n    export function setKeyboardRepeatDefault(delay: number, interval: number) {\n        defaultRepeatDelay = Math.max(delay, 0);\n        defaultRepeatInterval = Math.max(interval, 1);\n    }\n\n    //% blockId=browser_events_onAnyKeyEvent\n    //% block=\"on any key $event\"\n    //% group=\"Keyboard\"\n    //% weight=98\n    //% blockType=\"hat\"\n    //% draggableParameters=\"reporter\"\n    export function onAnyKeyEvent(event: KeyEvent, handler: () => void) {\n        // すべてのキーボタンに同じハンドラーを登録\n        const allKeys = [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,\n            Zero, One, Two, Three, Four, Five, Six, Seven, Eight, Nine,\n            Shift, Enter, CapsLock, Tab, Control, Meta, Alt,\n            ArrowUp, ArrowDown, ArrowLeft, ArrowRight,\n            BackTick, Hyphen, Equals, OpenBracket, CloseBracket, BackSlash,\n            Space, PageUp, SemiColon, Apostrophe, Comma, Period, ForwardSlash,\n            PageDown, End, Home, LeftShift, RightShift, LeftControl, RightControl,\n            Backspace, Delete];\n        for (const key of allKeys) {\n            key.addEventListener(event, handler);\n        }\n    }\n\n    //% blockId=browser_events_lastKeyPressed\n    //% block=\"last key pressed\"\n    //% group=\"Keyboard\"\n    //% weight=97\n    export function lastKeyPressed(): string {\n        return keyToString(_lastKeyPressed) || \"Unknown\";\n    }\n}"}]}],"snapshots":[{"timestamp":1768911506481,"editorVersion":"2.0.63","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"KeyEvents+\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1768911582471}